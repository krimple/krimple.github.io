webpackJsonp([2,5],{3:function(t,n,e){t.exports=e("IrbH")},IrbH:function(t,n,e){e("P+fo")(e("fU6Z"))},"P+fo":function(t,n){t.exports=function(t){"undefined"!=typeof execScript?execScript(t):eval.call(null,t)}},fU6Z:function(t,n){t.exports='/* Hammer-time - v0.3.0\n * http://github.com/hammerjs/hammer-time\n *\n * Copyright Alexander Schmitz and other contributors\n * Released under the MIT license\n *\n * Expiramental fastclick based on a partial polyfill of\n * touch-action: none; CSS property\n */\n\n( function() {\n\n\t// Detect support for necessary features;\n\tvar MO = window.MutationObserver || window.WebKitMutationObserver;\n\tvar touchevents = ( "ontouchstart" in window ) ||\n\t                  ( window.DocumentTouch && document instanceof DocumentTouch );\n\tvar nativeTouchAction = document.documentElement.style[ "touch-action" ] !== undefined ||\n\t\t\t                            document.documentElement.style[ "-ms-touch-action" ];\n\n// If there is native touch action bail the hammer has already dropped\nif ( nativeTouchAction || !touchevents || !MO ) {\n\treturn;\n}\n\n//Check if a global Hammer object already exists\nwindow.Hammer = window.Hammer || {};\n\n// We need to save the last touch start in iOS 8 if it is more then 150ms\n// it will trigger native fast click which cant ne stoped even with all the might\n// of thors hammer and a return false\nvar touchMatchNone = /touch-action[:][\\s]*(none)[^;\'"]*/;\nvar touchMatchManipulation = /touch-action[:][\\s]*(manipulation)[^;\'"]*/;\nvar touchMatch = /touch-action/;\nvar timeTouch = /(iP(ad|hone|od))/.test( navigator.userAgent ) && ( "indexedDB" in window || !!window.performance );\n\nwindow.Hammer.time = {\n\n\t// Check if an element has touch action none in its style attribute and thusly should\n\t// be hammered upon\n\tgetTouchAction: function( element ) {\n\t\treturn this.checkStyleString( element.getAttribute( "style" ) );\n\t},\n\tcheckStyleString: function( style ) {\n\t\tif ( !touchMatch.test( style ) ) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif ( touchMatchNone.test( style ) ) {\n\t\t\treturn "none";\n\t\t}\n\t\tif ( touchMatchManipulation.test( style ) ) {\n\t\t\treturn "manipulation";\n\t\t}\n\t\treturn true;\n\t},\n\tshouldHammer: function( e ) {\n\t\tvar parentAction = e.target.hasParent;\n\t\treturn ( parentAction && ( !timeTouch || Date.now() - e.target.lastStart < 125 ) ) ?\n\t\t\t\tparentAction : false;\n\t},\n\ttouchHandler: function( e ) {\n\t\tvar hammerType = this.shouldHammer( e );\n\n\t\t// Check both if we should trigger fast click and the time to avoid a double trigger with\n\t\t// native fast click\n\t\tif ( hammerType === "none" ) {\n\t\t\tthis.dropHammer( e );\n\t\t} else if ( hammerType === "manipulation" ) {\n\t\t\tvar pos = e.target.getBoundingClientRect();\n\t\t\tvar scrolled = pos.top !== this.pos.top || pos.left !== this.pos.left;\n\t\t\t!scrolled && this.dropHammer( e );\n\t\t}\n\t\tthis.scrolled = false;\n\t\tdelete e.target.lastStart;\n\t\tdelete e.target.hasParent;\n\t},\n\tdropHammer: function( e ) {\n\t\tif ( e.type === "touchend" ) {\n\t\t\te.target.focus();\n\n\t\t\t// Wait for next tic so events fire in proper order\n\t\t\tsetTimeout( function() {\n\t\t\t\te.target.click();\n\t\t\t}, 0 );\n\t\t}\n\n\t\t// Prevent the click which will come after this otherwise but with a 300ms delay\n\t\te.preventDefault();\n\t},\n\ttouchStart: function( e ) {\n\t\tthis.pos = e.target.getBoundingClientRect();\n\t\te.target.hasParent = this.hasParent( e.target );\n\t\tif ( timeTouch && e.target.hasParent ) {\n\t\t\te.target.lastStart = Date.now();\n\t\t}\n\t},\n\tstyleWatcher: function( mutations ) {\n\t\tmutations.forEach( this.styleUpdater, this );\n\t},\n\tstyleUpdater: function( mutation ) {\n\n\t\t// We just caused this update bail\n\t\tif ( mutation.target.updateNext ) {\n\t\t\tmutation.target.updateNext = false;\n\t\t\treturn;\n\t\t}\n\n\t\tvar touchAction = this.getTouchAction( mutation.target );\n\n\t\tif ( touchAction ) {\n\t\t\tif ( touchAction !== "none" ) {\n\t\t\t\tmutation.target.hadTouchNone = false;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif ( !touchAction &&\n\t\t\t\t(\n\t\t\t\t\t( mutation.oldValue && this.checkStyleString( mutation.oldValue ) ) ||\n\t\t\t\t\tmutation.target.hadTouchNone\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t// We save this because during animations which update the style in quick succession\n\t\t\t// style tag can update quicker then the mutation observer fires so we lose the oldValue\n\t\t\t// property which contains our refrence to the original which contained touch-action.\n\t\t\tmutation.target.hadTouchNone = true;\n\n\t\t\t// Save the fact that we caused the next update\n\t\t\tmutation.target.updateNext = false;\n\n\t\t\t// Add touch action back to the style attribute\n\t\t\tmutation.target\n\t\t\t\t.setAttribute( "style",\n\t\t\t\t\tmutation.target.getAttribute( "style" ) + " touch-action: none;"\n\t\t\t\t);\n\n\t\t}\n\t},\n\thasParent: function( node ) {\n\t\tvar touchAction;\n\t\tfor ( var cur = node; cur && cur.parentNode; cur = cur.parentNode ) {\n\t\t\ttouchAction = this.getTouchAction( cur );\n\t\t\tif ( touchAction ) {\n\t\t\t\treturn touchAction;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tinstallStartEvents: function() {\n\t\tdocument.addEventListener( "touchstart", this.touchStart.bind( this ) );\n\t\tdocument.addEventListener( "mousedown", this.touchStart.bind( this ) );\n\t},\n\tinstallEndEvents: function() {\n\t\tdocument.addEventListener( "touchend", this.touchHandler.bind( this ), true );\n\t\tdocument.addEventListener( "mouseup", this.touchHandler.bind( this ), true );\n\t},\n\tinstallObserver: function() {\n\n\t\t// We need to observe changes to style attributes because if something updates the style\n\t\t// attribute it will remove the touch-action property because browsers santitize the style\n\t\t// attribute when its properties are updated.\n\t\tthis.observer = new MO( this.styleWatcher.bind( this ) ).observe( document, {\n\t\t\tsubtree: true,\n\t\t\tattributes: true,\n\t\t\tattributeOldValue: true,\n\t\t\tattributeFilter: [ "style" ]\n\t\t} );\n\t},\n\tinstall: function() {\n\t\tthis.installEndEvents();\n\t\tthis.installStartEvents();\n\t\tthis.installObserver();\n\t}\n};\n\nwindow.Hammer.time.install();\n\n} )();\n'}},[3]);